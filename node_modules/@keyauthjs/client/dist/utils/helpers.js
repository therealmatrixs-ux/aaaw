"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertTimestampsToLocalDates = exports.downloadToFile = exports.downloadToString = exports.timeUntilExpiry = exports.convertUnixTimestampToLocalDate = exports.timeSince = void 0;
const fs_1 = require("fs");
/**
 * Calculates the time elapsed since a given date or timestamp.
 *
 * @param {Date | string} timeSince - The date or timestamp to calculate the time since.
 * @returns {string | 0} - A string describing the time elapsed or 0 if it's less than a minute.
 */
function timeSince(timeSince) {
    // Get the current date and time
    const currentDate = new Date();
    // Convert the input to a Date object or multiply it by 1000 if it's in seconds
    const joinDate = new Date(timeSince instanceof Date ? timeSince : timeSince * 1000);
    // Calculate the time difference in milliseconds
    const timeDifference = currentDate - joinDate;
    // Calculate time units
    const seconds = Math.floor(timeDifference / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    // Return the appropriate string based on the elapsed time
    if (days > 0) {
        return `${days} day${days !== 1 ? "s" : ""} ago`;
    }
    else if (hours > 0) {
        return `${hours} hour${hours !== 1 ? "s" : ""} ago`;
    }
    else if (minutes > 0) {
        return `${minutes} minute${minutes !== 1 ? "s" : ""} ago`;
    }
    else {
        // If it's less than a minute, return 0
        return 0;
    }
}
exports.timeSince = timeSince;
/**
 * Converts a Unix timestamp to a local Date object.
 *
 * @param {string} timestampString - The Unix timestamp as a string.
 * @returns {Date} - A Date object representing the local date and time.
 */
function convertUnixTimestampToLocalDate(timestampString) {
    // Parse the input timestamp string as an integer
    const unixTimestamp = parseInt(timestampString);
    // Convert the Unix timestamp to milliseconds and create a Date object
    return new Date(unixTimestamp * 1000); // Convert seconds to milliseconds
}
exports.convertUnixTimestampToLocalDate = convertUnixTimestampToLocalDate;
/**
 * Calculates the time remaining until a given expiry date or timestamp.
 *
 * @param {Date | string} expiry - The expiry date or timestamp.
 * @returns {string} - A string describing the time remaining.
 */
function timeUntilExpiry(expiry) {
    // Get the current date and time
    const currentDate = new Date();
    // Convert the expiry input into a Date object (if it's not already)
    const expiryDate = new Date(expiry instanceof Date ? expiry : expiry * 1000); // Convert seconds to milliseconds
    // Calculate the time difference between the expiry and current date
    const timeDifference = expiryDate - currentDate;
    // Calculate seconds, minutes, hours, and days from the time difference
    const seconds = Math.floor(timeDifference / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    // Construct a human-readable string describing the time remaining
    if (days > 0) {
        return `${days} day${days !== 1 ? "s" : ""} left`;
    }
    else if (hours > 0) {
        return `${hours} hour${hours !== 1 ? "s" : ""} left`;
    }
    else if (minutes > 0) {
        return `${minutes} minute${minutes !== 1 ? "s" : ""} left`;
    }
    else {
        return `${seconds} second${seconds !== 1 ? "s" : ""} left`;
    }
}
exports.timeUntilExpiry = timeUntilExpiry;
/**
 * Converts a downloaded response to a string.
 *
 * @param {DownloadResponse} downloadResponse - The response containing downloadable content.
 * @returns {string} - The downloaded content as a string.
 */
function downloadToString(downloadResponse) {
    // Convert the hexadecimal content of the download response into a byte array
    const byteArray = new Uint8Array(downloadResponse.contents
        .match(/.{1,2}/g) // Split content into pairs of hexadecimal digits
        .map((byte) => parseInt(byte, 16)));
    // Decode the byte array into a string
    const decodedString = new TextDecoder().decode(byteArray);
    // Return the downloaded content as a string
    return decodedString;
}
exports.downloadToString = downloadToString;
/**
 * Downloads content to a file.
 *
 * @param {DownloadResponse} downloadResponse - The response containing downloadable content.
 * @param {string} name - The name of the file.
 * @param {string} fileType - The type or extension of the file.
 * @param {string} location - The location where the file will be saved.
 */
function downloadToFile(downloadResponse, name, fileType, location) {
    // Convert the hexadecimal content of the download response into a byte array
    const byteArray = new Uint8Array(downloadResponse.contents
        .match(/.{1,2}/g) // Split content into pairs of hexadecimal digits
        .map((byte) => parseInt(byte, 16)));
    // Write the byte array to a file
    (0, fs_1.writeFile)(`${location}/${name}.${fileType}`.replace("//", "/"), // Build the file path
    byteArray, // Write the byte array
    "utf8", // Encoding format
    (err) => {
        if (err) {
            // Handle errors if any
            console.error("Error writing to file:", err);
        }
        else {
            // File write successful
            console.log(`Data has been written to ${`${location}/${name}.${fileType}`.replace("//", "/")}`);
        }
    });
}
exports.downloadToFile = downloadToFile;
/**
 * Converts timestamps in user data to local Date objects.
 *
 * @param {Info} data - User information object containing timestamps.
 * @returns {Info} - User information object with converted timestamps.
 */
function convertTimestampsToLocalDates(data) {
    // Create a copy of the input data to avoid modifying the original object
    const convertedUser = { ...data };
    // Create an array to store converted subscription objects
    const convertedSubs = [];
    // Convert the 'createdate' timestamp to a local Date object
    convertedUser.createdate = convertUnixTimestampToLocalDate(data.createdate);
    // Convert the 'lastlogin' timestamp to a local Date object
    convertedUser.lastlogin = convertUnixTimestampToLocalDate(data.lastlogin);
    // Iterate through the subscriptions and convert their 'expiry' timestamps
    if (data.subscriptions)
        data.subscriptions.forEach((sub) => {
            const convertedSub = { ...sub };
            // Convert the 'expiry' timestamp to a local Date object
            convertedSub.expiry = convertUnixTimestampToLocalDate(convertedSub.expiry);
            // Add the converted subscription to the array
            convertedSubs.push(convertedSub);
        });
    // Replace the original subscriptions with the converted array
    convertedUser.subscriptions = convertedSubs;
    // Return the user information object with converted timestamps
    return convertedUser;
}
exports.convertTimestampsToLocalDates = convertTimestampsToLocalDates;
